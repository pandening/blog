《程序员数学》一书读后感
=================================

```java
    今天是2017年6月17日，我还在天津，我还在学校，我还没有毕业。但是，再过半个月，我就要离开学校，离开天津。到那个
时候，我就毕业了，我就不在天津了。
    在这个非常具有历史意义的、承上启下的关键时刻，我的内心竟然毫无波动，甚至想写写代码看看书。说来也是怪事啊。可是
事实却是就是这样，我早上10点之前出门，然后去实验室，晚上11点之前半小时会宿舍，然后，要么去洗澡，要么直接上床，干嘛
呢？看论文。嗯，我现在养成了一些很好的习惯，比如作息规律，比如每天都让自己有所收获，看论文的目的就是让自己有所收获。
我总是觉得自己比别人差一点，有时候感觉差的很多，有时候感觉差的还好，所以，有时候我会比较玩命去学习，有时候就不那么
积极。但是总是选择去让自己变得更加强大的，我觉得我是对的，嗯！
   看《程序员的数学》的契机是什么呢？我忘了，反正很多事情我都会忘记，但是有些事情却记得很牢，比如我会忘记中午吃的
 菜是什么，但是我不会忘记几年前我在厕所里捡到10块钱这件事情。所以我就是不知道什么原因的搜索了比如“书名” + “pdf”
 这样的关键字，然后习惯性的找到CSDN字样，然后点进去下载，居然是高清的。
     这是我第一本一口气读完的计算机相关书籍。很显然它写的足够吸引我去阅读，而且，关键是，它足够简单，简单到我非常想找
 到一个知识点我无法理解，就像物品阅读其他书籍那样，有时候一个难点我要想很久才能搞明白，甚至想不明白。这本书的神奇之处
 就在于，你通篇阅读之后，觉得非常顺畅，但是你能想起来书中的很多内容，而不像很多书，你读完后反而觉得你没读过。我觉得是
 因为读完一本书的时间太长了，而且难点密集的书籍会分散你的注意了，你只好每个点都弄明白，最后读完之后你确实收获很多，但是
 你除了最后的难点，还有可能除了最开始的难点之外，其他你征服了的难点你一时半会想不起来，这就是说，某个知识你是会的，但是
 你想不起来，你得需要再重新刺激你才能想起来。而本书，我一口气读完了，顺带还用草稿纸推了书中的算式，写了代码，甚至在电脑
 上运行，这一套操作下来简直不能再连贯了，我收获很多，然后我发现，我居然是一个喜欢简单事物的程序员。
   第一章讲0的故事，读完就明白了；
   第二章讲代数逻辑，读完就明白了；
   第三章讲余数，读完就明白了，但是从程序的角度讨论了余数，这是亮点，讲到了周期和分组，这对程序员在解决一些问题时是很有
帮助的。
   第四章讲数学归纳，要跟着推导，读完也就明白了。
   第五章讲计数，排列与组合，有很多实例，非常好理解。
   第六章讲递归，这是本书的亮点，最大的亮点，我的关注点全在这一章，因为我对递归的理解在看完这一章后有了新的提高，书中的
例子对我的帮助很大，我主要思考的地方也在这一章。
   第七章讲指数，告诉我们指数级别的复杂度到底多么可怕。
   第八章讲不可解问题，我不太在意，因为我现在还没有解决那些可解的问题，研究不可解问题为时过早。
   最后的内容就是总结。
```
递归，{"GNU" is Not Unix}
------------------------------
```
      很显然，GNU是"GNU" is Not Unix的缩写，可是GNU到底是什么鬼？什么？我刚才不是说过了嘛？这就是递归，自己定义自己，这
  个说法不太准确，稍后我会重新说这个定义。
      章节用汉诺塔问题作为导入问题，很快引起了我的注意，因为这个问题在我刚学编程之初就困扰我了，直到我读到这一章节，读完后
   我弄明白了。其实问题是很简单的，做法也很简单，只是我当初没有理解递归，我觉得，谁都会觉得递归难以理解吧？我甚至觉得，真正
   理解了递归之后，人生就算是上了一个台阶了啊。
       现在根据我自己的理解，说说怎么去解决递归问题，以及怎么写代码来模拟递归过程。我觉得，解决递归问题分三步，即：
             1、找到问题的子结构（子结构）
             2、假设子问题已知，探索如何用子问题来定义整个问题，因为问题被分成子问题，子问题理应可以定义整个问题。
             3、一直用子问题定义问题，然后当一个问题真的有解了的时候，不需要再定义下去了，这时候，整个假设栈就都可以解了。
       这样看来，解决递归问题是不是很简单啊。那用这个思路来解决汉诺塔问题试试看。
     ----------------------------------------------------  
     |    |              |             |                |
     |   ---             |             |                |
     |  -----            |             |                |
     | -------        -------       -------             |
     | pillar A        pillar B       paiiar C          |
     ----------------------------------------------------
       
       汉诺塔问题就是将A柱子上的盘子移动到B柱子上面去，C柱子可以当做中转柱子，要求在转移的过程中大的盘子不可以放在小的盘子上面，我
   们先从简单的问题开始，当没有盘子在A上时，也就是n = 0时，所需要转移的次数为0.这是一个已知的问题，当有一个盘子在A上时，直接将它转
   移到B，完成，需要移动一次，好像到现在我们也看不出来有什么规律可寻，但是，当A柱子上的盘子变为2时，首先，需要将最上面的小盘子放到
   C上，然后将A上剩下的盘子移动到B，此时，问题变为从C柱子移动1个盘子到B柱子的汉诺塔问题，这就是一个子问题。如果这个时候还不明白这其
   中的玄机，那让n=3，经过移动，可以发现一个中间状态为：
     ------------------------------------------------------
     |    |              |               |                |
     |    |              |               |                |
     |    |              |              ---               |
     |    |            -------         -----              |
     | pillar A        pillar B       paiiar C            |
     ------------------------------------------------------
     
     这个问题就变为从C专业2个盘子到B的问题，这属于从A转移3个盘子到B这个汉诺塔问题的子问题，如果我们用H(n)表示从A转移n个盘子到B的汉诺
  塔问题，那么可以用H(n-1)问题来定义H(n)问题如下：
            H(n)   =    H(n-1)   +   1    +   H(n-1)
          \------/     \------/    \---/     \-------/
         从A转移n个盘子到B  ||        ||           | 
            的汉诺塔问题    |         |           从C移动n-1个盘子到B
                         先将n-1个   再将最大的盘子从A移动到B
                         盘子移动到
                         C
     如果用代码来实现这个过程，就如下：
```
```java
    /**
     * the move times
     */
    private static Integer count = 0;

    /**
     * the hanoi problem: move n plates from x to y
     * @param n n plates
     * @param x source pillar
     * @param y dest pillar
     * @param z tmp pillar
     */
    private static void hanoi(Integer n,char x,char y,char z){
        if( n > 0 ){
            //if n == 0 just ignore
            /**
             * step 1:move n-1 dish from x to z
             */
            hanoi(n-1,x,z,y);
            /**
             * step 2: move the biggest plate to y
             */
            count ++;
            p("move one dish from " + x + " to " + y);
            /**
             * step 3: move n-1 plates from z to y
             */
            hanoi(n-1,z,y,x);
        }
    }
```
```
   书中该章节还有其他丰富的实例来说明递归问题，甚至将排列组合问题与递归联系到了一起，对我的影响特别巨大。在书中的师生对话中，我发现了
一句非常有意思的话：“把握结构是分解整个问题的突破口”。这句话就好像再说，当你无法一次性解决一件事情的时候，就去研究这件事情的内在结构，也
就是去了解问题的本质，然后试着将问题分解成可以解决的小问题(子结构)，这样，再大的问题也能迎刃而解了。说的简单，可是做起啦却很难，递归就是
这样解决问题的，同样将问题拆开解的方法还有分治算法。也许，递归和分治最终的本质就是一样的，可是我还不理解，再接再厉吧！

```
